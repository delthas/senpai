// Code generated by go-varlink/varlinkgen. DO NOT EDIT.

package varlinkservice

import (
	"encoding/json"

	govarlink "github.com/emersion/go-varlink"
)

type OpenLinkIn struct {
	Link string `json:"link"`
}
type OpenLinkOut struct{}

type Client struct {
	*govarlink.Client
}

func unmarshalError(err error) error {
	verr, ok := err.(*govarlink.ClientError)
	if !ok {
		return err
	}
	var v error
	switch verr.Name {
	default:
		return err
	}
	if err := json.Unmarshal(verr.Parameters, v); err != nil {
		return err
	}
	return v
}
func (c Client) OpenLink(in *OpenLinkIn) (*OpenLinkOut, error) {
	if in == nil {
		in = new(OpenLinkIn)
	}
	out := new(OpenLinkOut)
	err := c.Client.Do("fr.delthas.senpai.OpenLink", in, out)
	return out, unmarshalError(err)
}

type Backend interface {
	OpenLink(*OpenLinkIn) (*OpenLinkOut, error)
}

type Handler struct {
	Backend Backend
}

func marshalError(err error) error {
	var name string
	switch err.(type) {
	default:
		return err
	}
	return &govarlink.ServerError{
		Name:       name,
		Parameters: err,
	}
}
func (h Handler) HandleVarlink(call *govarlink.ServerCall, req *govarlink.ServerRequest) error {
	var (
		out interface{}
		err error
	)
	switch req.Method {
	case "fr.delthas.senpai.OpenLink":
		in := new(OpenLinkIn)
		if err := json.Unmarshal(req.Parameters, in); err != nil {
			return err
		}
		out, err = h.Backend.OpenLink(in)
	default:
		err = &govarlink.ServerError{
			Name:       "org.varlink.service.MethodNotFound",
			Parameters: map[string]string{"method": req.Method},
		}
	}
	if err != nil {
		return marshalError(err)
	}
	return call.CloseWithReply(out)
}

func (h Handler) Register(reg *govarlink.Registry) {
	reg.Add(&govarlink.RegistryInterface{
		Definition: "interface fr.delthas.senpai\n\nmethod OpenLink(link: string) -> ()\n",
		Name:       "fr.delthas.senpai",
	}, h)
}
